#include "UniformBuffers.hlsl"
#include "Utilities.hlsl"

#define DEPTH_EPSILON 0.01f
#define STATIC_BLEND_FACTOR 1

[[vk::binding(0)]]
ConstantBuffer<CameraBuffer> camera;

[[vk::binding(1)]]
Texture2D<float> depth;

[[vk::binding(2)]]
Texture2D<float2> velocity;

[[vk::binding(3)]]
Texture2D<float4> colour;

[[vk::binding(4)]]
Texture2D<float4> history;

[[vk::binding(5)]]
RWTexture2D<float4> newHistory;

[[vk::binding(6)]]
SamplerState linearSampler;

// Rather than clamp within the colour space AABB, clip it.
float3 clip_aabb(	float3 aabb_min, 
				float3 aabb_max, 
				float3 q)        
{
	float3 p_clip= 0.5 * (aabb_max+ aabb_min);
	float3 e_clip= 0.5 * (aabb_max-aabb_min);

	float3 v_clip= q -p_clip;
	float3 v_unit= v_clip.xyz/ e_clip;
	float3 a_unit= abs(v_unit);
	float ma_unit= max(a_unit.x, max(a_unit.y,a_unit.z));

	if (ma_unit> 1.0)
		return p_clip + v_clip/ ma_unit;
	else
		return q;
}

[numthreads(32, 32, 1)]
void main(uint3 globalIndex : SV_DispatchThreadID)
{
	const float2 gbufferSize = camera.frameBufferSize;
	const float2 uv = (float2(globalIndex.xy) / gbufferSize);

	const float fragDepth = depth.Sample(linearSampler, uv);;
	const float linearDepth = lineariseReverseDepth(fragDepth, camera.nearPlane, camera.farPlane);

	float2 currentVelocity = velocity.Sample(linearSampler, uv);
	currentVelocity = (currentVelocity - 0.5f) * 2.0f;

	const float2 previousUV = uv - currentVelocity;
#if !STATIC_BLEND_FACTOR
	const float previousDepth = depth.Sample(linearSampler, previousUV);
	const float previousLinearDepth = lineariseReverseDepth(previousDepth, camera.nearPlane, camera.farPlane);
	const float depthDif = abs(previousLinearDepth - linearDepth);
#endif

	const float4 currentColour = colour.Sample(linearSampler, uv);
	
	const float xDiff = 1.0f / camera.frameBufferSize.x;
	const float yDiff = 1.0f / camera.frameBufferSize.y;

	// Calcaulte a AABB in YCoCg colour space for neibourghhood clipping.
	float3 upColour = colour.Sample(linearSampler, uv + float2(xDiff, 0.0f)).xyz;
	float3 downColour = colour.Sample(linearSampler, uv + float2(-xDiff, 0.0f)).xyz;
	float3 leftColour = colour.Sample(linearSampler, uv + float2(0.0f, -yDiff)).xyz;
	float3 rightColour = colour.Sample(linearSampler, uv + float2(0.0f, yDiff)).xyz;
	upColour = calculateYCoCg(upColour);
	downColour = calculateYCoCg(downColour);
	leftColour = calculateYCoCg(leftColour);
	rightColour = calculateYCoCg(rightColour);
	const float3 currentColourYCocg = calculateYCoCg(currentColour.xyz);

	float3 aabbMin = float3(100000.0f);
	float3 aabbMax = float3(-100000.0f);
	// Min
	aabbMin = min(aabbMin, upColour);
	aabbMin = min(aabbMin, downColour);
	aabbMin = min(aabbMin, leftColour);
	aabbMin = min(aabbMin, rightColour);
	aabbMin = min(aabbMin, currentColourYCocg);

	// Max
	aabbMax = max(aabbMax, upColour);
	aabbMax = max(aabbMax, downColour);
	aabbMax = max(aabbMax, leftColour);
	aabbMax = max(aabbMax, rightColour);
	aabbMax = max(aabbMax, currentColourYCocg);

	float4 historyColour = history.Sample(linearSampler, previousUV);

	// Clamp previous colour
	float3 previousColourYCoCg = calculateYCoCg(historyColour.xyz);
	previousColourYCoCg = clip_aabb(aabbMin, aabbMax, previousColourYCoCg);

	historyColour.xyz = calculateRGB(previousColourYCoCg);

#if STATIC_BLEND_FACTOR
	const float confidence = 0.9f;
#else
	// Check how close (in depth) the two fragments are.
	float confidence = (1.0f - (depthDif / DEPTH_EPSILON)) * 0.5f;
	confidence *= 1.0f - (dot(abs(previousColourYCoCg.xy - currentColourYCocg.xy), float2(1.0f)) / 2.0f);
	confidence *= confidence;
#endif

	float4 newColour =  ((1.0f - confidence) * currentColour) + (confidence * historyColour);

	if(globalIndex.x <= gbufferSize.x && globalIndex.y <= gbufferSize.y)
			newHistory[globalIndex.xy] = newColour; 
}
