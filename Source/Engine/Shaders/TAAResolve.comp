#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "UniformBuffers.glsl"
#include "Utilities.glsl"

#define DEPTH_EPSILON 0.01f
#define STATIC_BLEND_FACTOR 0

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform cameraBuffer
{
	CameraBuffer camera;
};

layout(set = 0, binding = 1) uniform texture2D depth;

layout(set = 0, binding = 2) uniform texture2D velocity;

layout(set = 0, binding = 3) uniform texture2D colour;

layout(set = 0, binding = 4) uniform texture2D history;

layout(rgba8, set = 0, binding = 5) uniform image2D newHistory;

layout(set = 0, binding = 6) uniform sampler linearSampler;

// Rather than clamp within the colour space AABB, clip it.
float3 clip_aabb(	float3 aabb_min, 
				float3 aabb_max, 
				float3 p,        
				float3 q)        
{
	float3 p_clip= 0.5 * (aabb_max+ aabb_min);
	float3 e_clip= 0.5 * (aabb_max-aabb_min);

	float3 v_clip= q -p_clip;
	float3 v_unit= v_clip.xyz/ e_clip;
	float3 a_unit= abs(v_unit);
	float ma_unit= max(a_unit.x, max(a_unit.y,a_unit.z));

	if (ma_unit> 1.0)
		return p_clip + v_clip/ ma_unit;
	else
		return q;
}

void main()
{
	const float2 gbufferSize = camera.frameBufferSize;
	const float2 uv = (float2(gl_GlobalInvocationID.xy) / gbufferSize);

	const float fragDepth = texture(sampler2D(depth, linearSampler), uv).x;
	const float linearDepth = lineariseReverseDepth(fragDepth, camera.nearPlane, camera.farPlane);

	float2 currentVelocity = texture(sampler2D(velocity, linearSampler), uv).xy;
	currentVelocity = (currentVelocity - 0.5f) * 2.0f;

	const float2 previousUV = uv - currentVelocity;
	const float previousDepth = texture(sampler2D(depth, linearSampler), previousUV).x;
	const float previousLinearDepth = lineariseReverseDepth(previousDepth, camera.nearPlane, camera.farPlane);

	const float4 currentColour = texture(sampler2D(colour, linearSampler), uv);

	const float depthDif = abs(previousLinearDepth - linearDepth);
	
	const float xDiff = 1.0f / camera.frameBufferSize.x;
	const float yDiff = 1.0f / camera.frameBufferSize.y;

	// Calcaulte a AABB in YCoCg colour space for neibourghhood clipping.
	float3 upColour = texture(sampler2D(history, linearSampler), uv + float2(xDiff, 0.0f)).xyz;
	float3 downColour = texture(sampler2D(history, linearSampler), uv + float2(-xDiff, 0.0f)).xyz;
	float3 leftColour = texture(sampler2D(history, linearSampler), uv + float2(0.0f, -yDiff)).xyz;
	float3 rightColour = texture(sampler2D(history, linearSampler), uv + float2(0.0f, yDiff)).xyz;
	upColour = calculateYCoCg(upColour);
	downColour = calculateYCoCg(downColour);
	leftColour = calculateYCoCg(leftColour);
	rightColour = calculateYCoCg(rightColour);
	const float3 currentColourYCocg = calculateYCoCg(currentColour.xyz);

	float3 aabbMin = float3(100000.0f);
	float3 aabbMax = float3(-100000.0f);
	// Min
	aabbMin = min(aabbMin, upColour);
	aabbMin = min(aabbMin, downColour);
	aabbMin = min(aabbMin, leftColour);
	aabbMin = min(aabbMin, rightColour);
	aabbMin = min(aabbMin, currentColourYCocg);

	// Max
	aabbMax = max(aabbMax, upColour);
	aabbMax = max(aabbMax, downColour);
	aabbMax = max(aabbMax, leftColour);
	aabbMax = max(aabbMax, rightColour);
	aabbMax = max(aabbMax, currentColourYCocg);

	float4 previousColour = texture(sampler2D(history, linearSampler), previousUV);

	// Clamp previous colour
	float3 previousColourYCoCg = calculateYCoCg(previousColour.xyz);
	previousColourYCoCg = clip_aabb(aabbMin, aabbMax, previousColourYCoCg, currentColourYCocg);

	previousColour.xyz = calculateRGB(previousColourYCoCg);

#if STATIC_BLEND_FACTOR
	const float confidence = 0.9f;
#else
	// Check how close (in depth) the two fragments are.
	float confidence = (1.0f - (depthDif / DEPTH_EPSILON)) * 0.5f;
	confidence *= 1.0f - (dot(abs(previousColourYCoCg.xy - currentColourYCocg.xy), float2(1.0f)) / 2.0f);
	confidence *= confidence;
#endif

	float4 newColour =  ((1.0f - confidence) * currentColour) + (confidence * previousColour);

	if(gl_GlobalInvocationID.x <= gbufferSize.x && gl_GlobalInvocationID.y <= gbufferSize.y)
			imageStore(newHistory, int2(gl_GlobalInvocationID.xy), newColour); 
}
