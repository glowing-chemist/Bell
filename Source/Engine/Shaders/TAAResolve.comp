#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "UniformBuffers.glsl"
#include "Utilities.glsl"

#define DEPTH_EPSILON 0.01f
#define STATIC_BLEND_FACTOR 1

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform cameraBuffer
{
	CameraBuffer camera;
};

layout(set = 0, binding = 1) uniform texture2D depth;

layout(set = 0, binding = 2) uniform texture2D colour;

layout(set = 0, binding = 3) uniform texture2D history;

layout(rgba8, set = 0, binding = 4) uniform image2D newHistory;

layout(set = 0, binding = 5) uniform sampler linearSampler;

// Rather than clamp within the colour space AABB, clip it.
vec3 clip_aabb(	vec3 aabb_min, 
				vec3 aabb_max, 
				vec3 p,        
				vec3 q)        
{
	vec3 p_clip= 0.5 * (aabb_max+ aabb_min);
	vec3 e_clip= 0.5 * (aabb_max-aabb_min);

	vec3 v_clip= q -p_clip;
	vec3 v_unit= v_clip.xyz/ e_clip;
	vec3 a_unit= abs(v_unit);
	float ma_unit= max(a_unit.x, max(a_unit.y,a_unit.z));

	if (ma_unit> 1.0)
		return p_clip + v_clip/ ma_unit;
	else
		return q;
}

void main()
{
	const vec2 gbufferSize = camera.frameBufferSize;
	const vec2 uv = (vec2(gl_GlobalInvocationID.xy) / gbufferSize) + camera.jitter;

	const float fragDepth = texture(sampler2D(depth, linearSampler), uv).x;
	const float linearDepth = lineariseReverseDepth(fragDepth, camera.nearPlane, camera.farPlane);

	vec4 positionWS = camera.invertedViewProj * vec4((uv - 0.5f) * 2.0f, fragDepth, 1.0f);
	positionWS /= positionWS.w;

	vec4 previousPosition = camera.previousFrameViewProj * positionWS;
	previousPosition /= previousPosition.w;

	const vec2 previousUV = ((previousPosition.xy * 0.5f) + 0.5f) - camera.previousJitter;
	const float previousDepth = texture(sampler2D(depth, linearSampler), previousUV).x;
	const float previousLinearDepth = lineariseReverseDepth(previousDepth, camera.nearPlane, camera.farPlane);

	const vec4 currentColour = texture(sampler2D(colour, linearSampler), uv);

	vec4 newColour = currentColour;
	// Only include history if the depth is within the threshold.
	const float depthDif = abs(previousLinearDepth - linearDepth);
	if(depthDif <= DEPTH_EPSILON)
	{
		const float xDiff = 1.0f / camera.frameBufferSize.x;
		const float yDiff = 1.0f / camera.frameBufferSize.y;

		// Calcaulte a AABB in YCoCg colour space for neibourghhood clipping.
		vec3 upColour = texture(sampler2D(colour, linearSampler), uv + vec2(xDiff, 0.0f)).xyz;
		vec3 downColour = texture(sampler2D(colour, linearSampler), uv + vec2(-xDiff, 0.0f)).xyz;
		vec3 leftColour = texture(sampler2D(colour, linearSampler), uv + vec2(0.0f, -yDiff)).xyz;
		vec3 rightColour = texture(sampler2D(colour, linearSampler), uv + vec2(0.0f, yDiff)).xyz;
		upColour = calculateYCoCg(upColour);
		downColour = calculateYCoCg(downColour);
		leftColour = calculateYCoCg(leftColour);
		rightColour = calculateYCoCg(rightColour);
		const vec3 currentColourYCocg = calculateYCoCg(currentColour.xyz);

		vec3 aabbMin = vec3(100000.0f);
		vec3 aabbMax = vec3(-100000.0f);
		// Min
		aabbMin = min(aabbMin, upColour);
		aabbMin = min(aabbMin, downColour);
		aabbMin = min(aabbMin, leftColour);
		aabbMin = min(aabbMin, rightColour);
		aabbMin = min(aabbMin, currentColourYCocg);

		// Max
		aabbMax = max(aabbMax, upColour);
		aabbMax = max(aabbMax, downColour);
		aabbMax = max(aabbMax, leftColour);
		aabbMax = max(aabbMax, rightColour);
		aabbMax = max(aabbMax, currentColourYCocg);

		vec4 previousColour = texture(sampler2D(history, linearSampler), previousUV);

		// Clamp previous colour
		vec3 previousColourYCoCg = calculateYCoCg(previousColour.xyz);
		previousColourYCoCg = clip_aabb(aabbMin, aabbMax, currentColourYCocg, previousColourYCoCg);

		previousColour.xyz = calculateRGB(previousColourYCoCg);

#if STATIC_BLEND_FACTOR
		const float confidence = 0.9f;
#else
		// Check how close (in depth) the two fragments are.
		float confidence = (1.0f - (depthDif / DEPTH_EPSILON)) * 0.5f;
		confidence *= 1.0f - (dot(abs(previousColourYCoCg.xy - currentColourYCocg.xy), vec2(1.0f)) / 2.0f);
		confidence *= confidence;
#endif

		newColour =  ((1.0f - confidence) * currentColour) + (confidence * previousColour);
	}

	if(gl_GlobalInvocationID.x <= gbufferSize.x && gl_GlobalInvocationID.y <= gbufferSize.y)
			imageStore(newHistory, ivec2(gl_GlobalInvocationID.xy), newColour); 
}
