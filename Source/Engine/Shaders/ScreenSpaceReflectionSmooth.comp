#include "VertexOutputs.hlsl"
#include "UniformBuffers.hlsl"
#include "NormalMapping.hlsl"
#include "PBR.hlsl"
#include "Utilities.hlsl"


[[vk::binding(0)]]
Texture2D<float2> LinearDepth;

[[vk::binding(1)]]
Texture2D<float> Depth;

[[vk::binding(2)]]
Texture2D<float4> diffuse;

[[vk::binding(3)]]
Texture2D<float4> specular;

[[vk::binding(4)]]
Texture2D<float3> Normals;

[[vk::binding(5)]]
StructuredBuffer<uint2> tileList;

[[vk::binding(6)]]
TextureCube<float4> skybox;

[[vk::binding(7)]]
SamplerState linearSampler;

[[vk::binding(8)]]
ConstantBuffer<CameraBuffer> camera;

[[vk::binding(9)]]
RWTexture2D<float4> reflectionMap;

#define START_MIP 7

#include "RayMarching.hlsl"

[numthreads(8, 8, 1)]
void main(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
	const uint flattenedThreadPosition = groupID.x;
	const uint2 tileIndex = tileList[flattenedThreadPosition];
	const uint2 threadIndex = (tileIndex * uint2(8, 8)) + groupThreadID.xy;
	const float2 uv = (float2(threadIndex) / (camera.frameBufferSize / 2.0f)) + camera.jitter;

	const float fragmentDepth = Depth.Sample(linearSampler, uv);

	if(fragmentDepth == 0.0f) // skybox.
		return;

	float4 positionWS =  mul(camera.invertedViewProj, float4((uv - 0.5f) * 2.0f, fragmentDepth, 1.0f));
	positionWS /= positionWS.w;

	float3 position = float3((uv - 0.5f) * 2.0f, fragmentDepth);

	float3 view = normalize(camera.position - positionWS.xyz);

	float3 normal = Normals.Sample(linearSampler, uv);
	normal = normalize(remapNormals(normal));

	uint width, height;
	LinearDepth.GetDimensions(width, height);
	width >>= START_MIP;
	height >>= START_MIP;

	float4 reflectedColour = float4(0.0f, 0.0f, 0.0f, 1.0f);

	const float3 L = reflect(-view, normal);

	const float max_distance = max(max(camera.sceneSize.x, camera.sceneSize.y), camera.sceneSize.z);
	float4 rayEnd = float4(positionWS + (L * max_distance), 1.0f);
	rayEnd = mul(camera.viewProj, rayEnd);
	rayEnd /= rayEnd.w;

	const float3 rayDirection = normalize(rayEnd.xyz - position.xyz);

	{
		// March the ray.
		const float2 colourUV = marchRay(position, rayDirection, 30, float2(1.0f, 1.0f) / float2(width, height), START_MIP, camera.nearPlane, camera.farPlane, camera.invertedPerspective);
		if(all(colourUV >= float2(0.0f, 0.0f)))
		{
			reflectedColour += diffuse.Sample(linearSampler, colourUV);
			reflectedColour += float4(specular.Sample(linearSampler, colourUV).xyz, 1.0f);
		}
		else
		{
			reflectedColour = skybox.SampleLevel(linearSampler, L, 0.0f);
		}
	}


	reflectionMap[threadIndex] = reflectedColour;
}