#include "UniformBuffers.hlsl"

[[vk::binding(0)]]
Texture2D<float4> specularRoughness;

[[vk::binding(1)]]
RWStructuredBuffer<uint3> roughIndirectArgs;

[[vk::binding(2)]]
RWStructuredBuffer<uint3> smoothIndirectArgs;

[[vk::binding(3)]]
RWStructuredBuffer<uint2> roughTileList;

[[vk::binding(4)]]
RWStructuredBuffer<uint> roughTileCount;

[[vk::binding(5)]]
RWStructuredBuffer<uint2> smoothTileList;

[[vk::binding(6)]]
RWStructuredBuffer<uint> smoothTileCount;

[[vk::binding(7)]]
ConstantBuffer<CameraBuffer> camera;

[[vk::binding(8)]]
SamplerState linearSampler;

groupshared uint4 accumilatedSpecularMaxRoughness;

[numthreads(8, 8, 1)]
void main(uint3 globalIndex : SV_DispatchThreadID, uint3 groupThreadID : SV_GroupThreadID)
{
	if(groupThreadID.x == 0 && groupThreadID.y == 0 && groupThreadID.z == 0)
		accumilatedSpecularMaxRoughness = uint4(0, 0, 0, 0);

	AllMemoryBarrierWithGroupSync();

	const float2 uv = float2(globalIndex.xy) / camera.frameBufferSize;
	const float4 specularR = specularRoughness.Sample(linearSampler, uv);
	const uint4 specularRI = uint4(specularR * 255.0f);

	uint orig;
	InterlockedMax(accumilatedSpecularMaxRoughness.w, specularRI.w, orig);

	uint3 specOrig;
	InterlockedAdd(accumilatedSpecularMaxRoughness.x, specularRI.x, specOrig.x);
	InterlockedAdd(accumilatedSpecularMaxRoughness.y, specularRI.y, specOrig.y);
	InterlockedAdd(accumilatedSpecularMaxRoughness.z, specularRI.z, specOrig.z);

	AllMemoryBarrierWithGroupSync();

	if(groupThreadID.x == 0 && groupThreadID.y == 0 && groupThreadID.z == 0)
	{
		if(all(accumilatedSpecularMaxRoughness.xyz == uint3(0, 0, 0)))
			return;

		if(accumilatedSpecularMaxRoughness.w < 50)
		{
			// Write out a smooth tile.
			uint tileIndex;
			InterlockedAdd(smoothTileCount[0], 1, tileIndex);
			smoothTileList[tileIndex] = globalIndex / uint2(8u, 8u);
		}
		else
		{
			// write out a rough tile.
			uint tileIndex;
			InterlockedAdd(roughTileCount[0], 1, tileIndex);
			roughTileList[tileIndex] = globalIndex / uint2(8u, 8u);
		}
	}
}