#include "VertexOutputs.hlsl"
#include "Utilities.hlsl"


struct BoneIndex
{
    uint mBone;
    float mWeight;
};

struct BoneIndicies
{
    BoneIndex mBoneIndices[13];
    uint mUsedBones;
    uint padding;
};

struct Bone
{
	float4x4 transform;
};

struct Constants
{
    uint mVertexCount;
    uint mVertexReadIndex;
    uint mVertexWriteIndex;
    uint patchIndex;
    uint mVertexStride;
};

[[vk::binding(0)]]
ByteAddressBuffer TPoseBuffer;

[[vk::binding(4)]]
RWByteAddressBuffer outVertex;

[[vk::binding(5)]]
ByteAddressBuffer VertexPatchBuffer;

[[vk::push_constant]]
ConstantBuffer<Constants> meshInfo;


[numthreads(32, 1, 1)]
void main(uint3 globalIndex : SV_DispatchThreadID)
{
	const uint vertexIndex = globalIndex.x;

	if(vertexIndex >= meshInfo.mVertexCount)
		return;

	Vertex vertToProcess = readVertexFromBuffer(TPoseBuffer, (meshInfo.mVertexReadIndex + vertexIndex) * meshInfo.mVertexStride);

	Vertex vertexPatch = readVertexFromBuffer(VertexPatchBuffer, (meshInfo.patchIndex + vertexIndex) * meshInfo.mVertexStride)

	Vertex transformedVertex;
	transformedVertex.position = /*vertToProcess.position +*/ vertexPatch.position;
	transformedVertex.uv = /*vertToProcess.uv +*/ vertexPatch.uv;
	transformedVertex.normal = /*vertToProcess.normal +*/ vertexPatch.normal;
	transformedVertex.colour = vertexPatch.colour;

	writeVertexToBuffer(outVertex, (meshInfo.mVertexWriteIndex + vertexIndex) * meshInfo.mVertexStride, transformedVertex);
}