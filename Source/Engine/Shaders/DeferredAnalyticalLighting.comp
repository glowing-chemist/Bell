#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "UniformBuffers.glsl"
#include "NormalMapping.glsl"
#include "ClusteredLighting.glsl"


layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform cameraBuffer
{
	CameraBuffer camera;
};

// GBuffer
layout(set = 0, binding = 1) uniform texture2D DFG;
layout(set = 0, binding = 2) uniform texture2D ltcMat;
layout(set = 0, binding = 3) uniform texture2D ltcAmp;
layout(set = 0, binding = 4) uniform texture2D depth;
layout(set = 0, binding = 5) uniform texture2D vertexNormals;
layout(set = 0, binding = 6) uniform texture2D Albedo;
layout(set = 0, binding = 7) uniform texture2D MetalnessRoughness;
layout(set = 0, binding = 8) uniform sampler linearSampler;
layout(set = 0, binding = 9) uniform sampler pointSampler;

// Light lists
layout(std430, set = 0, binding = 10) buffer readonly sparseFroxels
{
	uvec2 sparseFroxelList[];
};

layout(std430, set = 0,  binding = 11) buffer froxelIndicies
{
	uint indicies[];
};

layout(set = 0, binding = 12) uniform utexture2D activeFroxels;

layout(rgba8, set = 0, binding = 13) uniform writeonly image2D accumilatedLight;

layout(std430, set = 1, binding = 0) buffer readonly sceneLights
{
	uvec4  lightCount;
	Light lights[];
};


void main()
{
	const vec2 gbufferSize = camera.frameBufferSize;
	const vec2 uv = vec2(gl_GlobalInvocationID.xy) / gbufferSize;

	if(gl_GlobalInvocationID.x >= gbufferSize.x || gl_GlobalInvocationID.y >= gbufferSize.y)
		return;

	const float fragmentDepth = texture(sampler2D(depth, linearSampler), uv).x;

	vec4 worldSpaceFragmentPos = camera.invertedViewProj * vec4((uv - 0.5f) * 2.0f, fragmentDepth, 1.0f);
	worldSpaceFragmentPos /= worldSpaceFragmentPos.w;

	vec3 normal;
    normal = texture(sampler2D(vertexNormals, linearSampler), uv).xyz;
    normal = remapNormals(normal);
    normal = normalize(normal);

    const vec3 viewDir = normalize(vec4(camera.position, 1.0f) - worldSpaceFragmentPos).xyz;

    const vec3 baseAlbedo = texture(sampler2D(Albedo, linearSampler), uv).xyz;
    const float roughness = texture(sampler2D(MetalnessRoughness, linearSampler), uv).y;
    const float metalness = texture(sampler2D(MetalnessRoughness, linearSampler), uv).x;

    const uint froxelIndex = texture(usampler2D(activeFroxels, pointSampler), uv).x;
    const uvec2 lightListIndicies = sparseFroxelList[froxelIndex];

    // Initialize needed lighting params.
    mat3 minV;
    float LTCAmp;
    vec2 f_ab;
    initializeLightState(minV, LTCAmp, f_ab, DFG, ltcMat, ltcAmp, linearSampler, dot(normal, viewDir), roughness);

    vec4 accum = vec4(0.0f);

    for(uint i = 0; i < lightListIndicies.y; ++i)
    {
    	uint indirectLightIndex = indicies[lightListIndicies.x + i];
    	const Light light = lights[indirectLightIndex];

    	switch(uint(light.type))
		{
			case 0: // Point.
			{

    			vec4 lighting =  pointLightContribution(light, worldSpaceFragmentPos, viewDir, normal, metalness, roughness, baseAlbedo, f_ab);
    			accum += lighting;
				break;
			}

			case 1: // Spot.
			{
				vec4 lighting =  pointLightContribution(light, worldSpaceFragmentPos, viewDir, normal, metalness, roughness, baseAlbedo, f_ab);
    			accum += lighting;	
				break;
			}

			case 2: // Area.
			{
				vec4 lighting =  areaLightContribution(light, worldSpaceFragmentPos, viewDir, normal, metalness, roughness, baseAlbedo, minV, LTCAmp);
    			accum += lighting;	
				break;
			}

			// TODO add more light types as and when supported.

			// Should never hit here.
			default:
				continue;
		}
    }

    imageStore(accumilatedLight, ivec2(gl_GlobalInvocationID.xy), accum);
}
