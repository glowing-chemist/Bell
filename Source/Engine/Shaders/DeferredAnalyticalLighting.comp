#include "UniformBuffers.hlsl"
#include "NormalMapping.hlsl"
#include "ClusteredLighting.hlsl"


[[vk::binding(0)]]
ConstantBuffer<CameraBuffer> camera;

[[vk::binding(1)]]
Texture2D<float2> DFG;

[[vk::binding(2)]]
Texture2D<float4> ltcMat;

[[vk::binding(3)]]
Texture2D<float2> ltcAmp;

[[vk::binding(4)]]
Texture2D<float> depth;

[[vk::binding(5)]]
Texture2D<float4> vertexNormals;

[[vk::binding(6)]]
Texture2D<float4> Albedo;

[[vk::binding(7)]]
Texture2D<float2> MetalnessRoughness;

[[vk::binding(8)]]
SamplerState linearSampler;

[[vk::binding(9)]]
SamplerState pointSampler;

[[vk::binding(10)]]
StructuredBuffer<uint2> sparseFroxelList;

[[vk::binding(11)]]
StructuredBuffer<uint> indicies;

[[vk::binding(12)]]
Texture2D<uint> activeFroxels;

[[vk::binding(13)]]
RWTexture2D<float4> accumilatedLight;


[[vk::binding(0, 1)]]
StructuredBuffer<uint4> lightCount;

[[vk::binding(1, 1)]]
StructuredBuffer<Light> sceneLights;


[numthreads(32, 32, 1)]
void main(uint3 globalIndex : SV_DispatchThreadID)
{
	const float2 gbufferSize = camera.frameBufferSize;
	const float2 uv = float2(globalIndex.xy) / gbufferSize;

	if(globalIndex.x >= gbufferSize.x || globalIndex.y >= gbufferSize.y)
		return;

	const float fragmentDepth = depth.Sample(linearSampler, uv);

	float4 worldSpaceFragmentPos = mul(camera.invertedViewProj, float4((uv - 0.5f) * 2.0f, fragmentDepth, 1.0f));
	worldSpaceFragmentPos /= worldSpaceFragmentPos.w;

	float3 normal;
    normal = vertexNormals.Sample(linearSampler, uv);
    normal = remapNormals(normal);
    normal = normalize(normal);

    const float3 viewDir = normalize(float4(camera.position, 1.0f) - worldSpaceFragmentPos).xyz;

    const float3 baseAlbedo = Albedo.Sample(linearSampler, uv).xyz;
    const float2 metalnessRoughness = MetalnessRoughness.Sample(linearSampler, uv);
    const float roughness = metalnessRoughness.y;
    const float metalness = metalnessRoughness.x;

    const uint froxelIndex = activeFroxels.Sample(pointSampler, uv);
    const uint2 lightListIndicies = sparseFroxelList[froxelIndex];

    // Initialize needed lighting params.
    float3x3 minV;
    float LTCAmp;
    float2 f_ab;
    initializeLightState(minV, LTCAmp, f_ab, DFG, ltcMat, ltcAmp, linearSampler, dot(normal, viewDir), roughness);

    float4 accum = float4(0.0f);

    for(uint i = 0; i < lightListIndicies.y; ++i)
    {
    	uint indirectLightIndex = indicies[lightListIndicies.x + i];
    	const Light light = sceneLights[indirectLightIndex];

    	switch(uint(light.type))
		{
			case 0: // Point.
			{

    			float4 lighting =  pointLightContribution(light, worldSpaceFragmentPos, viewDir, normal, metalness, roughness, baseAlbedo, f_ab);
    			accum += lighting;
				break;
			}

			case 1: // Spot.
			{
				float4 lighting =  pointLightContribution(light, worldSpaceFragmentPos, viewDir, normal, metalness, roughness, baseAlbedo, f_ab);
    			accum += lighting;	
				break;
			}

			case 2: // Area.
			{
				float4 lighting =  areaLightContribution(light, worldSpaceFragmentPos, viewDir, normal, metalness, roughness, baseAlbedo, minV, LTCAmp);
    			accum += lighting;	
				break;
			}

			// TODO add more light types as and when supported.

			// Should never hit here.
			default:
				continue;
		}
    }

    accumilatedLight[globalIndex.xy] = accum;
}
