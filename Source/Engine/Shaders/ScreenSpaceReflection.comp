#include "VertexOutputs.hlsl"
#include "UniformBuffers.hlsl"
#include "NormalMapping.hlsl"
#include "PBR.hlsl"
#include "Utilities.hlsl"


[[vk::binding(0)]]
Texture2D<float2> LinearDepth;

[[vk::binding(1)]]
Texture2D<float> Depth;

[[vk::binding(2)]]
Texture2D<float3> Normals;

[[vk::binding(3)]]
SamplerState linearSampler;

[[vk::binding(4)]]
ConstantBuffer<CameraBuffer> camera;

[[vk::binding(5)]]
RWTexture2D<float2> reflectionUV;

#define START_MIP 7

#include "RayMarching.hlsl"

[numthreads(8, 8, 1)]
void main(uint3 globalIndex : SV_DispatchThreadID)
{
	const float2 uv = (float2(globalIndex.xy) / (camera.frameBufferSize / 2.0f)) + camera.jitter;

	const float fragmentDepth = Depth.Sample(linearSampler, uv);

	if(fragmentDepth == 0.0f) // skybox.
		return;

	float4 positionWS =  mul(camera.invertedViewProj, float4((uv - 0.5f) * 2.0f, fragmentDepth, 1.0f));
	positionWS /= positionWS.w;

	float3 position = float3((uv - 0.5f) * 2.0f, fragmentDepth);

	float3 view = normalize(camera.position - positionWS.xyz);

	float3 normal = Normals.Sample(linearSampler, uv);
	normal = normalize(remapNormals(normal));

	uint width, height;
	LinearDepth.GetDimensions(width, height);
	width >>= START_MIP;
	height >>= START_MIP;

	float4 reflectedColour = float4(0.0f, 0.0f, 0.0f, 1.0f);

	const float3 L = reflect(-view, normal);

	const float max_distance = max(max(camera.sceneSize.x, camera.sceneSize.y), camera.sceneSize.z);
	float4 rayEnd = float4(positionWS + (L * max_distance), 1.0f);
	rayEnd = mul(camera.viewProj, rayEnd);
	rayEnd /= rayEnd.w;

	const float3 rayDirection = normalize(rayEnd.xyz - position.xyz);

	// March the ray.
	const float2 colourUV = marchRay(position, rayDirection, 30, float2(1.0f, 1.0f) / float2(width, height), START_MIP, camera.nearPlane, camera.farPlane, camera.invertedPerspective);


	reflectionUV[globalIndex.xy] = colourUV;
}