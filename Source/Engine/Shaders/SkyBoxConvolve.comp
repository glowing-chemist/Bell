#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "PBR.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 6) in;

layout(binding = 0) uniform textureCube skyBox;
layout(binding = 1) uniform sampler defaultSampler;

// All the prefiltered cubemap mips
layout(rgba8, binding = 2) uniform writeonly imageCube mip0;
layout(rgba8, binding = 3) uniform writeonly imageCube mip1;
layout(rgba8, binding = 4) uniform writeonly imageCube mip2;
layout(rgba8, binding = 5) uniform writeonly imageCube mip3;
layout(rgba8, binding = 6) uniform writeonly imageCube mip4;
layout(rgba8, binding = 7) uniform writeonly imageCube mip5;
layout(rgba8, binding = 8) uniform writeonly imageCube mip6;
layout(rgba8, binding = 9) uniform writeonly imageCube mip7;
layout(rgba8, binding = 10) uniform writeonly imageCube mip8;
layout(rgba8, binding = 11) uniform writeonly imageCube mip9;


vec3 prefilterEnviromentMap(const float roughness, const vec3 R)
{
	vec3 N = R;
	vec3 V = R;

	vec3 prefilteredColor = vec3(0.0);

	float TotalWeight = 0.0;

	const uint SAMPLE_COUNT = 1024;
	for(uint i = 0; i < SAMPLE_COUNT; ++i)
	{
		vec2 Xi = Hammersley(i, SAMPLE_COUNT);
		vec3 H = ImportanceSampleGGX(Xi, roughness, N);
		vec3 L = 2 * dot(V, H) * H - V;

		float NoL = clamp(dot(N, L), 0.0f, 1.0f);
		if(NoL > 0.0)
		{
			prefilteredColor += texture(samplerCube(skyBox, defaultSampler), L).xyz * NoL;
			TotalWeight += NoL;
		}
	}

	return prefilteredColor / TotalWeight;
}


// Taken from http://hannosprogrammingblog.blogspot.com/2015/03/get-normal-for-cubemap-texel.html
vec3 getNormalFromTexel(const ivec3 texelPosition, const vec2 size)
{
	vec2 position = vec2(texelPosition.xy) / size;

	position -= 0.5; // remap 0-1 to -0.5-0.5
	position *= 2; // remap to -1-1

	const uint cubemapSide = texelPosition.z;

	vec3 normal;
	
	if(cubemapSide == 0) 
	{ // facing x-dir
		normal = vec3(1, -position.y, -position.x);
	} 
	else if(cubemapSide == 1) 
	{ // facing -x-dir
		normal = vec3(-1, -position.y, position.x);
	} 
	else if(cubemapSide == 2) 
	{ // facing y-dir
		normal = vec3(-position.x, 1, -position.y);
	} 
	else if(cubemapSide == 3) 
	{ // facing -y-dir
		normal = vec3(position.x, -1, -position.y);
	} 
	else if(cubemapSide == 4) 
	{ // facing z-dir
		normal = vec3(position.x, -position.y, 1);
	} 
	else if(cubemapSide == 5) 
	{ // facing -z-dir
		normal = vec3(-position.x, -position.y, -1);
	}
	
	return normalize(normal);
}


void main()
{
	const ivec3 dispatchLocation = ivec3(gl_GlobalInvocationID);

	float roughness = 0.0;
	{

		const vec2 size = imageSize(mip0);

		vec3 normal = getNormalFromTexel(dispatchLocation, size);

		vec3 convolvedColor = prefilterEnviromentMap(roughness, normal);

		if(dispatchLocation.x < size.x && dispatchLocation.y < size.y)
			imageStore(mip0, dispatchLocation, vec4(convolvedColor, 1.0f));

		roughness += 0.1;
	}

	{
		const vec2 size = imageSize(mip1);

		vec3 normal = getNormalFromTexel(dispatchLocation, size);

		vec3 convolvedColor = prefilterEnviromentMap(roughness, normal);

		if(dispatchLocation.x < size.x && dispatchLocation.y < size.y)
			imageStore(mip1, dispatchLocation, vec4(convolvedColor, 1.0f));

		roughness += 0.1;
	}

	{
		const vec2 size = imageSize(mip2);

		vec3 normal = getNormalFromTexel(dispatchLocation, size);

		vec3 convolvedColor = prefilterEnviromentMap(roughness, normal);

		if(dispatchLocation.x < size.x && dispatchLocation.y < size.y)
			imageStore(mip2, dispatchLocation, vec4(convolvedColor, 1.0f));

		roughness += 0.1;
	}

	{
		const vec2 size = imageSize(mip3);

		vec3 normal = getNormalFromTexel(dispatchLocation, size);

		vec3 convolvedColor = prefilterEnviromentMap(roughness, normal);

		if(dispatchLocation.x < size.x && dispatchLocation.y < size.y)
			imageStore(mip3, dispatchLocation, vec4(convolvedColor, 1.0f));

		roughness += 0.1;
	}

	{
		const vec2 size = imageSize(mip4);

		vec3 normal = getNormalFromTexel(dispatchLocation, size);

		vec3 convolvedColor = prefilterEnviromentMap(roughness, normal);

		if(dispatchLocation.x < size.x && dispatchLocation.y < size.y)
			imageStore(mip4, dispatchLocation, vec4(convolvedColor, 1.0f));

		roughness += 0.1;
	}

	{
		const vec2 size = imageSize(mip5);

		vec3 normal = getNormalFromTexel(dispatchLocation, size);

		vec3 convolvedColor = prefilterEnviromentMap(roughness, normal);

		if(dispatchLocation.x < size.x && dispatchLocation.y < size.y)
			imageStore(mip5, dispatchLocation, vec4(convolvedColor, 1.0f));

		roughness += 0.1;
	}

	{
		const vec2 size = imageSize(mip6);

		vec3 normal = getNormalFromTexel(dispatchLocation, size);

		vec3 convolvedColor = prefilterEnviromentMap(roughness, normal);

		if(dispatchLocation.x < size.x && dispatchLocation.y < size.y)
			imageStore(mip6, dispatchLocation, vec4(convolvedColor, 1.0f));

		roughness += 0.1;
	}

	{
		const vec2 size = imageSize(mip7);

		vec3 normal = getNormalFromTexel(dispatchLocation, size);

		vec3 convolvedColor = prefilterEnviromentMap(roughness, normal);

		if(dispatchLocation.x < size.x && dispatchLocation.y < size.y)
			imageStore(mip7, dispatchLocation, vec4(convolvedColor, 1.0f));

		roughness += 0.1;
	}

	{
		const vec2 size = imageSize(mip8);

		vec3 normal = getNormalFromTexel(dispatchLocation, size);

		vec3 convolvedColor = prefilterEnviromentMap(roughness, normal);

		if(dispatchLocation.x < size.x && dispatchLocation.y < size.y)
			imageStore(mip8, dispatchLocation, vec4(convolvedColor, 1.0f));

		roughness += 0.1;

	}

		{
		const vec2 size = imageSize(mip9);

		vec3 normal = getNormalFromTexel(dispatchLocation, size);

		vec3 convolvedColor = prefilterEnviromentMap(roughness, normal);

		if(dispatchLocation.x < size.x && dispatchLocation.y < size.y)
			imageStore(mip9, dispatchLocation, vec4(convolvedColor, 1.0f));
	}
}