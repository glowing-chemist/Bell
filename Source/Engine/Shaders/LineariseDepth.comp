#include "UniformBuffers.hlsl"
#include "Utilities.hlsl"

[[vk::binding(0)]]
RWTexture2D<float> linearDepthBufferMip0;

[[vk::binding(1)]]
RWTexture2D<float> linearDepthBufferMip1;

[[vk::binding(2)]]
RWTexture2D<float> linearDepthBufferMip2;

[[vk::binding(3)]]
RWTexture2D<float> linearDepthBufferMip3;

[[vk::binding(4)]]
RWTexture2D<float> linearDepthBufferMip4;

[[vk::binding(5)]]
RWTexture2D<float> linearDepthBufferMip5;

[[vk::binding(6)]]
Texture2D<float> gbufferDepth;

[[vk::binding(7)]]
ConstantBuffer<CameraBuffer> camera;

[[vk::binding(8)]]
SamplerState linearSampler;

groupshared float depthValues[32 * 32];


[numthreads(32, 32, 1)]
void main(uint3 globalIndex : SV_DispatchThreadID, 
		  uint3 localIndex : SV_GroupThreadID,
		  uint3 groupIndex : SV_GroupID)
{
	const float2 uv = float2(globalIndex.xy) / camera.frameBufferSize;

	const float depth = gbufferDepth.Sample(linearSampler, uv);
	float linearDepth = lineariseReverseDepth(depth, camera.nearPlane, camera.farPlane);

	linearDepth = saturate(linearDepth);

	depthValues[localIndex.x + (localIndex.y * 32)] = linearDepth;

	uint width, height;
	linearDepthBufferMip0.GetDimensions(width, height);

	if(globalIndex.x < width && globalIndex.y < height)
		linearDepthBufferMip0[globalIndex.xy] = linearDepth;

	AllMemoryBarrierWithGroupSync();

	// write the next mip.
	if(localIndex.x < 16 && localIndex.y < 16)
	{
		const float topLeft = depthValues[localIndex.x * 2 + (localIndex.y * 2 * 32)];
		const float topRight = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 32)) + 1];
		const float bottomLeft = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 32)) + 32];
		const float bottomRight = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 32)) + 32 + 1];

		const float minValue = max(max(topLeft, topRight), max(bottomLeft, bottomRight));

		uint width, height;
		linearDepthBufferMip1.GetDimensions(width, height);

		uint2 index = (groupIndex.xy * 16) + localIndex.xy;
		if(index.x < width && index.y < height)
			linearDepthBufferMip1[index] = minValue;

		depthValues[localIndex.x + (localIndex.y * 16)] = minValue;
	}
	else
		return;

	AllMemoryBarrierWithGroupSync();

	if(localIndex.x < 8 && localIndex.y < 8)
	{
		const float topLeft = depthValues[localIndex.x * 2 + (localIndex.y * 2 * 16)];
		const float topRight = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 16)) + 1];
		const float bottomLeft = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 16)) + 16];
		const float bottomRight = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 16)) + 16 + 1];

		const float minValue = max(max(topLeft, topRight), max(bottomLeft, bottomRight));

		uint width, height;
		linearDepthBufferMip2.GetDimensions(width, height);

		uint2 index = (groupIndex.xy * 8) + localIndex.xy;
		if(index.x < width && index.y < height)
			linearDepthBufferMip2[index] = minValue;

		depthValues[localIndex.x + (localIndex.y * 8)] = minValue;
	}
	else
		return;

	AllMemoryBarrierWithGroupSync();

	if(localIndex.x < 4 && localIndex.y < 4)
	{
		const float topLeft = depthValues[localIndex.x * 2 + (localIndex.y * 2 * 8)];
		const float topRight = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 8)) + 1];
		const float bottomLeft = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 8)) + 8];
		const float bottomRight = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 8)) + 8 + 1];

		const float minValue = max(max(topLeft, topRight), max(bottomLeft, bottomRight));

		uint width, height;
		linearDepthBufferMip3.GetDimensions(width, height);

		uint2 index = (groupIndex.xy * 4) + localIndex.xy;
		if(index.x < width && index.y < height)
			linearDepthBufferMip3[index] = minValue;

		depthValues[localIndex.x + (localIndex.y * 4)] = minValue;
	}
	else
		return;

	AllMemoryBarrierWithGroupSync();

	if(localIndex.x < 2 && localIndex.y < 2)
	{
		const float topLeft = depthValues[localIndex.x * 2 + (localIndex.y * 2 * 4)];
		const float topRight = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 4)) + 1];
		const float bottomLeft = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 4)) + 4];
		const float bottomRight = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 4)) + 4 + 1];

		const float minValue = max(max(topLeft, topRight), max(bottomLeft, bottomRight));

		uint width, height;
		linearDepthBufferMip4.GetDimensions(width, height);

		uint2 index = (groupIndex.xy * 2) + localIndex.xy;
		if(index.x < width && index.y < height)
			linearDepthBufferMip4[index] = minValue;

		depthValues[localIndex.x + (localIndex.y * 2)] = minValue;
	}
	else
		return;

	AllMemoryBarrierWithGroupSync();

	if(localIndex.x < 1 && localIndex.y < 1)
	{
		const float topLeft = depthValues[localIndex.x * 2 + (localIndex.y * 2 * 2)];
		const float topRight = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 2)) + 1];
		const float bottomLeft = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 2)) + 2];
		const float bottomRight = depthValues[(localIndex.x * 2 + (localIndex.y * 2 * 2)) + 2 + 1];

		const float minValue = max(max(topLeft, topRight), max(bottomLeft, bottomRight));

		uint width, height;
		linearDepthBufferMip5.GetDimensions(width, height);

		uint2 index = groupIndex.xy;
		if(index.x < width && index.y < height)
			linearDepthBufferMip5[index] = minValue;
	}

}