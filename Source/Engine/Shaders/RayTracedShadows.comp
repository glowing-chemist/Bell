#include "RayTracing.hlsl"
#include "UniformBuffers.hlsl"
#include "PBR.hlsl"
#include "NormalMapping.hlsl"


[[vk::binding(0)]]
ConstantBuffer<CameraBuffer> camera;

[[vk::binding(1)]]
Texture2D<float> depth;

[[vk::binding(2)]]
SamplerState linearSampler;

[[vk::binding(3)]]
RWTexture2D<float> shadowMap;

[[vk::binding(4)]]
ConstantBuffer<ShadowingLight> light;


[[vk::binding(0, 1)]]
//ByteAddressBuffer bvhNodes;
StructuredBuffer<BVHNode> bvhNodes;

[[vk::binding(1, 1)]]
StructuredBuffer<uint> bvhIndicies;

[[vk::binding(2, 1)]]
StructuredBuffer<MaterialOffsets> PrimToMatID;

[[vk::binding(3, 1)]]
ByteAddressBuffer vertexPositionBuffer;

[[vk::binding(4, 1)]]
StructuredBuffer<float2> vertexUVBuffer;

[[vk::binding(5, 1)]]
StructuredBuffer<uint> indexBuffer;

struct PushConstants
{
	uint sampleCount;
};
[[vk::push_constant]]
ConstantBuffer<PushConstants> constants;

void calculateConeTangentBitangent(const float3 dir, out float3 tangent, out float3 bitangent)
{
	float3 c1 = cross(dir, float3(1.0f, 0.0f, 0.0f));
	float3 c2 = cross(dir, float3(0.0f, 1.0f, 0.0f));

	tangent = normalize(lerp(c1, c2, length(c2) > length(c1)));
	bitangent = normalize(cross(tangent, dir));
}

float3x3 calculateConeTransformToWS(const float3 dir, const float3 tangent, const float3 bitangent)
{
	float invmax = rsqrt(max(dot(tangent, tangent), dot(bitangent, bitangent)));

	 return float3x3(tangent * invmax, bitangent * invmax, dir);
}

float3 getRyaDirConeSpace(const float coneAngleRadians, const float2 Xi)
{
	const float Nab = sin(coneAngleRadians / 2.0f);
	const float Nx = ((Xi.x - 0.5f) * 2.0f) * Nab;
	const float Ny = ((Xi.y - 0.5f) * 2.0f) * Nab;

	return float3( 2.0f * Nx * sqrt(1.0f - (Nx * Nx) - (Ny * Ny)),
				   2.0f * Ny * sqrt(1.0f - (Nx * Nx) - (Ny * Ny)),
				   1.0f - 2 * ((Nx * Nx) + (Ny * Ny)));
}


[numthreads(16, 16, 1)]
void main(uint3 globalIndex : SV_DispatchThreadID)
{
	uint width, height;
	shadowMap.GetDimensions(width, height);

	const float2 uv = (float2(globalIndex.xy) / float2(width, height)) + camera.jitter;
	const float fragmentDepth = depth.Sample(linearSampler, uv);

	if(fragmentDepth == 0.0f) // skybox
	{
		return;
	}

	float4 worldSpaceFragmentPos = mul(camera.invertedViewProj, float4((uv - 0.5f) * 2.0f, fragmentDepth, 1.0f));
    worldSpaceFragmentPos /= worldSpaceFragmentPos.w;

    const float3 coneSpaceRay = getRyaDirConeSpace(radians(0.125f), Hammersley(constants.sampleCount, 8));
    const float3 coneDir = normalize(light.position - worldSpaceFragmentPos.xyz);
    float3 tangent, bitangent;
    calculateConeTangentBitangent(coneDir, tangent, bitangent);
    const float3x3 coneToWS = calculateConeTransformToWS(coneDir, tangent, bitangent);
    const float3 rayDir = mul(coneSpaceRay, coneToWS);

    Ray shadowRay;
	shadowRay.position = worldSpaceFragmentPos.xyz;
	shadowRay.direction = rayDir;
	shadowRay.max_t = max(max(camera.sceneSize.x, camera.sceneSize.y), camera.sceneSize.z);
	shadowRay.min_t = max(max(camera.sceneSize.x, camera.sceneSize.y), camera.sceneSize.z) / 1000.0f;

	TriangleIntersector intersector;
	TriangleIntersection result;
	const bool shadowed = traverseBVH(bvhNodes, bvhIndicies, indexBuffer, vertexPositionBuffer, shadowRay, intersector, result);

	if(globalIndex.x < width && globalIndex.y < height)
		shadowMap[globalIndex.xy] = shadowed ? 0.15f : 1.0f;
}